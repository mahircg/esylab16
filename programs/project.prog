reset: 		br always >main
			nop
hardfault:	reti
			nop
memfault:	reti
			nop
sw_irq:		br always >sw_irq_handler
			nop


//Define device addresses
.align
sw_addr: 			.word 0x000F0004
lcd_addr: 			.word 0x000F0008
audio_addr: 		.word 0x000F000C
string_base: 		.word 0x000E0000

.align
sp_init:   			.word 0x410
ptr_axialmeter: 	.word 0x450
ptr_prev_state: 	.word 0x460
index: 				.word 0x470	//current note index
ddr_start_addr: 	.word 0x80
rs_mask: 			.word 0x200

//uses r3 as axialmeter and r4 as prevaxialmeter
sw_irq_handler:		
		ld08 r5,r3		//Copy axialmeter into prevaxialstate
		st08 r4,r5
		ld16 r5,r0		//Read axialmeter
		st08 r3,r5		//Store axialmeter value in mem
		reti
		nop


main:
		ldr sp, >sp_init		//68
        clr sr
		ldr r0,>sw_addr
		ldr r1,>lcd_addr
		ldr r2,>audio_addr
		ldr r3,>ptr_axialmeter		//Assign pointer addresses
		ldr r4,>ptr_prev_state
		clr r8
		st32 r3,r8					//Set memory locs to zero
		st32 r4,r8
		ldr r5,>index
		st32 r5,r8					//Set current index to zero
		
poll1:	ld32 r5,r1					//Wait until LCD is initialized
        rsh r5,r5,11				//94
        cmp neq r5,r8
        br true >poll1
        nop
		ldr r6,>ddr_start_addr
		st32 r1,r6
		
		
		
loop:	clr r8
		clr r6
		ld08 r6,r3					//r6 stores current value
		ld08 r7,r4					//r7 stores previous value
		xor r10,r6,r7
		cmp eq r10,r8  				//check if there is a change
		br true >loop 				//keep checking until change
		nop
		and r9,r10,r6		//122
		cmp neq r9,r8
		br true >loop
		nop
		clr r11						//If PC is at this instr., we have a direction change	
		addi r11,0x08  				//Check if it is up
		cmp eq r7,r11
		br true >up
		nop
		clr r11
		addi r11,0x40
		cmp eq r7,r11
		br true >down
		nop 
		br always >loop
		nop
//XXX: take care overflow and underflows!!
up:		ldr r10,>index		//154
		ld32 r5,r10
		addi r5,1		//XXX: first use then increment
		st32 r10,r5
		lsh r5,r5,2					//Multiply index by 4
		ldr r10,>string_base		//r10 holds base address
		add r10,r10,r5				//String address is base + index*4
		br always >clear_and_write
		nop
		
down:	ldr r10,>index
		ld32 r5,r10
		addi r5,-1
		st32 r10,r5
		lsh r5,r5,2					//Multiply index by 4
		ldr r10,>string_base		//r10 holds base address
		add r10,r10,r5				//String address is base + index*4
		br always >clear_and_write
		nop
		
//XXX: Poll here
clear_and_write:
	ldr r11,>ddr_start_addr		//Reset LCD DDRAM address
	st32 r1,r11
	clr r11
	addi r11,12
	clr r9

inc_addr:
poll2:
	clr r8		//198
	ld32 r5,r1
	rsh r5,r5,11
	cmp neq r5,r8
	br true >poll2					//Wait until device is available
	nop
	
	ldr r8,>rs_mask	//212
	ld08 r5,r10
	addi r10,1
	or r5,r5,r8
	st32 r1,r5
	cmp neq r9,r11
	br true >inc_addr          		//if i=cnt_top
    addi r9,1
	br always >loop
	nop
	
	
		
		
		